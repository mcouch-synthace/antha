// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/antha-lang/antha/driver/antha_quantstudio_v1/quantstudio.proto

/*
Package antha_quantstudio_v1 is a generated protocol buffer package.

It is generated from these files:
	github.com/antha-lang/antha/driver/antha_quantstudio_v1/quantstudio.proto

It has these top-level messages:
	Blank
	SessionOrError
	ExperimentFile
	Barcode
	BlockTypeOrError
	Error
	OptionalError
	StatusOrError
	ExperimentRequest
	TemplatedRequest
	BoolOrError
	Session
	Instrument
	SessionInstrument
	Credentials
*/
package antha_quantstudio_v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ErrorCode int32

const (
	ErrorCode_UNINITIALIZED               ErrorCode = 0
	ErrorCode_SESSION_INVALID             ErrorCode = 1
	ErrorCode_SESSION_EXISTING            ErrorCode = 2
	ErrorCode_AUTHENTICATION_FAILURE      ErrorCode = 3
	ErrorCode_USER_ACCOUNT_DISABLED       ErrorCode = 4
	ErrorCode_PASSWORD_EXPIRED            ErrorCode = 5
	ErrorCode_INSTRUMENT_UNKNOWN          ErrorCode = 6
	ErrorCode_INSTRUMENT_NOT_CONNECTED    ErrorCode = 7
	ErrorCode_INSTRUMENT_READY            ErrorCode = 8
	ErrorCode_INSTRUMENT_RUNNING          ErrorCode = 9
	ErrorCode_INSTRUMENT_PAUSED           ErrorCode = 10
	ErrorCode_INSTRUMENT_IN_ERROR         ErrorCode = 11
	ErrorCode_INSTRUMENT_FAIL_TO_START    ErrorCode = 12
	ErrorCode_INSTRUMENT_TRAY_OPENED      ErrorCode = 13
	ErrorCode_INSTRUMENT_TRAY_CLOSED      ErrorCode = 14
	ErrorCode_EXPERIMENT_NOT_FOUND        ErrorCode = 15
	ErrorCode_EXPERIMENT_READ_ERROR       ErrorCode = 16
	ErrorCode_EXPERIMENT_WRITE_ERROR      ErrorCode = 17
	ErrorCode_EXPERIMENT_VALIDATION_ERROR ErrorCode = 18
)

var ErrorCode_name = map[int32]string{
	0:  "UNINITIALIZED",
	1:  "SESSION_INVALID",
	2:  "SESSION_EXISTING",
	3:  "AUTHENTICATION_FAILURE",
	4:  "USER_ACCOUNT_DISABLED",
	5:  "PASSWORD_EXPIRED",
	6:  "INSTRUMENT_UNKNOWN",
	7:  "INSTRUMENT_NOT_CONNECTED",
	8:  "INSTRUMENT_READY",
	9:  "INSTRUMENT_RUNNING",
	10: "INSTRUMENT_PAUSED",
	11: "INSTRUMENT_IN_ERROR",
	12: "INSTRUMENT_FAIL_TO_START",
	13: "INSTRUMENT_TRAY_OPENED",
	14: "INSTRUMENT_TRAY_CLOSED",
	15: "EXPERIMENT_NOT_FOUND",
	16: "EXPERIMENT_READ_ERROR",
	17: "EXPERIMENT_WRITE_ERROR",
	18: "EXPERIMENT_VALIDATION_ERROR",
}
var ErrorCode_value = map[string]int32{
	"UNINITIALIZED":               0,
	"SESSION_INVALID":             1,
	"SESSION_EXISTING":            2,
	"AUTHENTICATION_FAILURE":      3,
	"USER_ACCOUNT_DISABLED":       4,
	"PASSWORD_EXPIRED":            5,
	"INSTRUMENT_UNKNOWN":          6,
	"INSTRUMENT_NOT_CONNECTED":    7,
	"INSTRUMENT_READY":            8,
	"INSTRUMENT_RUNNING":          9,
	"INSTRUMENT_PAUSED":           10,
	"INSTRUMENT_IN_ERROR":         11,
	"INSTRUMENT_FAIL_TO_START":    12,
	"INSTRUMENT_TRAY_OPENED":      13,
	"INSTRUMENT_TRAY_CLOSED":      14,
	"EXPERIMENT_NOT_FOUND":        15,
	"EXPERIMENT_READ_ERROR":       16,
	"EXPERIMENT_WRITE_ERROR":      17,
	"EXPERIMENT_VALIDATION_ERROR": 18,
}

func (x ErrorCode) String() string {
	return proto.EnumName(ErrorCode_name, int32(x))
}
func (ErrorCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type BlockType int32

const (
	BlockType_ERROR             BlockType = 0
	BlockType_ARRAY_CARD_SAMPLE BlockType = 7
	BlockType_WELL_384_20uL     BlockType = 8
	BlockType_WELL_96_100uL     BlockType = 9
	BlockType_WELL_96_200uL     BlockType = 10
)

var BlockType_name = map[int32]string{
	0:  "ERROR",
	7:  "ARRAY_CARD_SAMPLE",
	8:  "WELL_384_20uL",
	9:  "WELL_96_100uL",
	10: "WELL_96_200uL",
}
var BlockType_value = map[string]int32{
	"ERROR":             0,
	"ARRAY_CARD_SAMPLE": 7,
	"WELL_384_20uL":     8,
	"WELL_96_100uL":     9,
	"WELL_96_200uL":     10,
}

func (x BlockType) String() string {
	return proto.EnumName(BlockType_name, int32(x))
}
func (BlockType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Blank struct {
}

func (m *Blank) Reset()                    { *m = Blank{} }
func (m *Blank) String() string            { return proto.CompactTextString(m) }
func (*Blank) ProtoMessage()               {}
func (*Blank) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type SessionOrError struct {
	// Types that are valid to be assigned to Reply:
	//	*SessionOrError_Session
	//	*SessionOrError_Error
	//	*SessionOrError_Blank
	Reply isSessionOrError_Reply `protobuf_oneof:"reply"`
}

func (m *SessionOrError) Reset()                    { *m = SessionOrError{} }
func (m *SessionOrError) String() string            { return proto.CompactTextString(m) }
func (*SessionOrError) ProtoMessage()               {}
func (*SessionOrError) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isSessionOrError_Reply interface {
	isSessionOrError_Reply()
}

type SessionOrError_Session struct {
	Session *Session `protobuf:"bytes,1,opt,name=session,oneof"`
}
type SessionOrError_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}
type SessionOrError_Blank struct {
	Blank *Blank `protobuf:"bytes,3,opt,name=blank,oneof"`
}

func (*SessionOrError_Session) isSessionOrError_Reply() {}
func (*SessionOrError_Error) isSessionOrError_Reply()   {}
func (*SessionOrError_Blank) isSessionOrError_Reply()   {}

func (m *SessionOrError) GetReply() isSessionOrError_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *SessionOrError) GetSession() *Session {
	if x, ok := m.GetReply().(*SessionOrError_Session); ok {
		return x.Session
	}
	return nil
}

func (m *SessionOrError) GetError() *Error {
	if x, ok := m.GetReply().(*SessionOrError_Error); ok {
		return x.Error
	}
	return nil
}

func (m *SessionOrError) GetBlank() *Blank {
	if x, ok := m.GetReply().(*SessionOrError_Blank); ok {
		return x.Blank
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SessionOrError) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SessionOrError_OneofMarshaler, _SessionOrError_OneofUnmarshaler, _SessionOrError_OneofSizer, []interface{}{
		(*SessionOrError_Session)(nil),
		(*SessionOrError_Error)(nil),
		(*SessionOrError_Blank)(nil),
	}
}

func _SessionOrError_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SessionOrError)
	// reply
	switch x := m.Reply.(type) {
	case *SessionOrError_Session:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Session); err != nil {
			return err
		}
	case *SessionOrError_Error:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *SessionOrError_Blank:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Blank); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SessionOrError.Reply has unexpected type %T", x)
	}
	return nil
}

func _SessionOrError_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SessionOrError)
	switch tag {
	case 1: // reply.session
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Session)
		err := b.DecodeMessage(msg)
		m.Reply = &SessionOrError_Session{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &SessionOrError_Error{msg}
		return true, err
	case 3: // reply.blank
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Blank)
		err := b.DecodeMessage(msg)
		m.Reply = &SessionOrError_Blank{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SessionOrError_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SessionOrError)
	// reply
	switch x := m.Reply.(type) {
	case *SessionOrError_Session:
		s := proto.Size(x.Session)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SessionOrError_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SessionOrError_Blank:
		s := proto.Size(x.Blank)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ExperimentFile struct {
	Url string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
}

func (m *ExperimentFile) Reset()                    { *m = ExperimentFile{} }
func (m *ExperimentFile) String() string            { return proto.CompactTextString(m) }
func (*ExperimentFile) ProtoMessage()               {}
func (*ExperimentFile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ExperimentFile) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type Barcode struct {
	Barcode string `protobuf:"bytes,1,opt,name=barcode" json:"barcode,omitempty"`
}

func (m *Barcode) Reset()                    { *m = Barcode{} }
func (m *Barcode) String() string            { return proto.CompactTextString(m) }
func (*Barcode) ProtoMessage()               {}
func (*Barcode) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Barcode) GetBarcode() string {
	if m != nil {
		return m.Barcode
	}
	return ""
}

type BlockTypeOrError struct {
	// Types that are valid to be assigned to MaybeBlockType:
	//	*BlockTypeOrError_BlockType
	//	*BlockTypeOrError_Error
	MaybeBlockType isBlockTypeOrError_MaybeBlockType `protobuf_oneof:"maybe_block_type"`
}

func (m *BlockTypeOrError) Reset()                    { *m = BlockTypeOrError{} }
func (m *BlockTypeOrError) String() string            { return proto.CompactTextString(m) }
func (*BlockTypeOrError) ProtoMessage()               {}
func (*BlockTypeOrError) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isBlockTypeOrError_MaybeBlockType interface {
	isBlockTypeOrError_MaybeBlockType()
}

type BlockTypeOrError_BlockType struct {
	BlockType BlockType `protobuf:"varint,1,opt,name=block_type,json=blockType,enum=antha.quantstudio.v1.BlockType,oneof"`
}
type BlockTypeOrError_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*BlockTypeOrError_BlockType) isBlockTypeOrError_MaybeBlockType() {}
func (*BlockTypeOrError_Error) isBlockTypeOrError_MaybeBlockType()     {}

func (m *BlockTypeOrError) GetMaybeBlockType() isBlockTypeOrError_MaybeBlockType {
	if m != nil {
		return m.MaybeBlockType
	}
	return nil
}

func (m *BlockTypeOrError) GetBlockType() BlockType {
	if x, ok := m.GetMaybeBlockType().(*BlockTypeOrError_BlockType); ok {
		return x.BlockType
	}
	return BlockType_ERROR
}

func (m *BlockTypeOrError) GetError() *Error {
	if x, ok := m.GetMaybeBlockType().(*BlockTypeOrError_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BlockTypeOrError) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BlockTypeOrError_OneofMarshaler, _BlockTypeOrError_OneofUnmarshaler, _BlockTypeOrError_OneofSizer, []interface{}{
		(*BlockTypeOrError_BlockType)(nil),
		(*BlockTypeOrError_Error)(nil),
	}
}

func _BlockTypeOrError_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BlockTypeOrError)
	// maybe_block_type
	switch x := m.MaybeBlockType.(type) {
	case *BlockTypeOrError_BlockType:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.BlockType))
	case *BlockTypeOrError_Error:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("BlockTypeOrError.MaybeBlockType has unexpected type %T", x)
	}
	return nil
}

func _BlockTypeOrError_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BlockTypeOrError)
	switch tag {
	case 1: // maybe_block_type.block_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.MaybeBlockType = &BlockTypeOrError_BlockType{BlockType(x)}
		return true, err
	case 2: // maybe_block_type.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.MaybeBlockType = &BlockTypeOrError_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _BlockTypeOrError_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BlockTypeOrError)
	// maybe_block_type
	switch x := m.MaybeBlockType.(type) {
	case *BlockTypeOrError_BlockType:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.BlockType))
	case *BlockTypeOrError_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Error struct {
	Code ErrorCode `protobuf:"varint,1,opt,name=code,enum=antha.quantstudio.v1.ErrorCode" json:"code,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Error) GetCode() ErrorCode {
	if m != nil {
		return m.Code
	}
	return ErrorCode_UNINITIALIZED
}

type OptionalError struct {
	// Types that are valid to be assigned to MaybeError:
	//	*OptionalError_Blank
	//	*OptionalError_Error
	MaybeError isOptionalError_MaybeError `protobuf_oneof:"maybe_error"`
}

func (m *OptionalError) Reset()                    { *m = OptionalError{} }
func (m *OptionalError) String() string            { return proto.CompactTextString(m) }
func (*OptionalError) ProtoMessage()               {}
func (*OptionalError) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isOptionalError_MaybeError interface {
	isOptionalError_MaybeError()
}

type OptionalError_Blank struct {
	Blank *Blank `protobuf:"bytes,1,opt,name=blank,oneof"`
}
type OptionalError_Error struct {
	Error ErrorCode `protobuf:"varint,2,opt,name=error,enum=antha.quantstudio.v1.ErrorCode,oneof"`
}

func (*OptionalError_Blank) isOptionalError_MaybeError() {}
func (*OptionalError_Error) isOptionalError_MaybeError() {}

func (m *OptionalError) GetMaybeError() isOptionalError_MaybeError {
	if m != nil {
		return m.MaybeError
	}
	return nil
}

func (m *OptionalError) GetBlank() *Blank {
	if x, ok := m.GetMaybeError().(*OptionalError_Blank); ok {
		return x.Blank
	}
	return nil
}

func (m *OptionalError) GetError() ErrorCode {
	if x, ok := m.GetMaybeError().(*OptionalError_Error); ok {
		return x.Error
	}
	return ErrorCode_UNINITIALIZED
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OptionalError) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OptionalError_OneofMarshaler, _OptionalError_OneofUnmarshaler, _OptionalError_OneofSizer, []interface{}{
		(*OptionalError_Blank)(nil),
		(*OptionalError_Error)(nil),
	}
}

func _OptionalError_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OptionalError)
	// maybe_error
	switch x := m.MaybeError.(type) {
	case *OptionalError_Blank:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Blank); err != nil {
			return err
		}
	case *OptionalError_Error:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Error))
	case nil:
	default:
		return fmt.Errorf("OptionalError.MaybeError has unexpected type %T", x)
	}
	return nil
}

func _OptionalError_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OptionalError)
	switch tag {
	case 1: // maybe_error.blank
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Blank)
		err := b.DecodeMessage(msg)
		m.MaybeError = &OptionalError_Blank{msg}
		return true, err
	case 2: // maybe_error.error
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.MaybeError = &OptionalError_Error{ErrorCode(x)}
		return true, err
	default:
		return false, nil
	}
}

func _OptionalError_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OptionalError)
	// maybe_error
	switch x := m.MaybeError.(type) {
	case *OptionalError_Blank:
		s := proto.Size(x.Blank)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *OptionalError_Error:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Error))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type StatusOrError struct {
	// Types that are valid to be assigned to MaybeStatus:
	//	*StatusOrError_Status
	//	*StatusOrError_Error
	MaybeStatus isStatusOrError_MaybeStatus `protobuf_oneof:"maybe_status"`
}

func (m *StatusOrError) Reset()                    { *m = StatusOrError{} }
func (m *StatusOrError) String() string            { return proto.CompactTextString(m) }
func (*StatusOrError) ProtoMessage()               {}
func (*StatusOrError) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isStatusOrError_MaybeStatus interface {
	isStatusOrError_MaybeStatus()
}

type StatusOrError_Status struct {
	Status ErrorCode `protobuf:"varint,1,opt,name=status,enum=antha.quantstudio.v1.ErrorCode,oneof"`
}
type StatusOrError_Error struct {
	Error ErrorCode `protobuf:"varint,2,opt,name=error,enum=antha.quantstudio.v1.ErrorCode,oneof"`
}

func (*StatusOrError_Status) isStatusOrError_MaybeStatus() {}
func (*StatusOrError_Error) isStatusOrError_MaybeStatus()  {}

func (m *StatusOrError) GetMaybeStatus() isStatusOrError_MaybeStatus {
	if m != nil {
		return m.MaybeStatus
	}
	return nil
}

func (m *StatusOrError) GetStatus() ErrorCode {
	if x, ok := m.GetMaybeStatus().(*StatusOrError_Status); ok {
		return x.Status
	}
	return ErrorCode_UNINITIALIZED
}

func (m *StatusOrError) GetError() ErrorCode {
	if x, ok := m.GetMaybeStatus().(*StatusOrError_Error); ok {
		return x.Error
	}
	return ErrorCode_UNINITIALIZED
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StatusOrError) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StatusOrError_OneofMarshaler, _StatusOrError_OneofUnmarshaler, _StatusOrError_OneofSizer, []interface{}{
		(*StatusOrError_Status)(nil),
		(*StatusOrError_Error)(nil),
	}
}

func _StatusOrError_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StatusOrError)
	// maybe_status
	switch x := m.MaybeStatus.(type) {
	case *StatusOrError_Status:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Status))
	case *StatusOrError_Error:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Error))
	case nil:
	default:
		return fmt.Errorf("StatusOrError.MaybeStatus has unexpected type %T", x)
	}
	return nil
}

func _StatusOrError_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StatusOrError)
	switch tag {
	case 1: // maybe_status.status
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.MaybeStatus = &StatusOrError_Status{ErrorCode(x)}
		return true, err
	case 2: // maybe_status.error
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.MaybeStatus = &StatusOrError_Error{ErrorCode(x)}
		return true, err
	default:
		return false, nil
	}
}

func _StatusOrError_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StatusOrError)
	// maybe_status
	switch x := m.MaybeStatus.(type) {
	case *StatusOrError_Status:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Status))
	case *StatusOrError_Error:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Error))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ExperimentRequest struct {
	SessionInstrument *SessionInstrument `protobuf:"bytes,1,opt,name=session_instrument,json=sessionInstrument" json:"session_instrument,omitempty"`
	ExperimentFile    *ExperimentFile    `protobuf:"bytes,2,opt,name=experiment_file,json=experimentFile" json:"experiment_file,omitempty"`
	Barcode           *Barcode           `protobuf:"bytes,3,opt,name=barcode" json:"barcode,omitempty"`
}

func (m *ExperimentRequest) Reset()                    { *m = ExperimentRequest{} }
func (m *ExperimentRequest) String() string            { return proto.CompactTextString(m) }
func (*ExperimentRequest) ProtoMessage()               {}
func (*ExperimentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ExperimentRequest) GetSessionInstrument() *SessionInstrument {
	if m != nil {
		return m.SessionInstrument
	}
	return nil
}

func (m *ExperimentRequest) GetExperimentFile() *ExperimentFile {
	if m != nil {
		return m.ExperimentFile
	}
	return nil
}

func (m *ExperimentRequest) GetBarcode() *Barcode {
	if m != nil {
		return m.Barcode
	}
	return nil
}

type TemplatedRequest struct {
	SessionInstrument *SessionInstrument `protobuf:"bytes,1,opt,name=session_instrument,json=sessionInstrument" json:"session_instrument,omitempty"`
	TemplateFile      *ExperimentFile    `protobuf:"bytes,2,opt,name=template_file,json=templateFile" json:"template_file,omitempty"`
	Barcode           *Barcode           `protobuf:"bytes,3,opt,name=barcode" json:"barcode,omitempty"`
	OutputPath        string             `protobuf:"bytes,4,opt,name=output_path,json=outputPath" json:"output_path,omitempty"`
}

func (m *TemplatedRequest) Reset()                    { *m = TemplatedRequest{} }
func (m *TemplatedRequest) String() string            { return proto.CompactTextString(m) }
func (*TemplatedRequest) ProtoMessage()               {}
func (*TemplatedRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *TemplatedRequest) GetSessionInstrument() *SessionInstrument {
	if m != nil {
		return m.SessionInstrument
	}
	return nil
}

func (m *TemplatedRequest) GetTemplateFile() *ExperimentFile {
	if m != nil {
		return m.TemplateFile
	}
	return nil
}

func (m *TemplatedRequest) GetBarcode() *Barcode {
	if m != nil {
		return m.Barcode
	}
	return nil
}

func (m *TemplatedRequest) GetOutputPath() string {
	if m != nil {
		return m.OutputPath
	}
	return ""
}

type BoolOrError struct {
	// Types that are valid to be assigned to MaybeBool:
	//	*BoolOrError_Result
	//	*BoolOrError_Error
	MaybeBool isBoolOrError_MaybeBool `protobuf_oneof:"maybe_bool"`
}

func (m *BoolOrError) Reset()                    { *m = BoolOrError{} }
func (m *BoolOrError) String() string            { return proto.CompactTextString(m) }
func (*BoolOrError) ProtoMessage()               {}
func (*BoolOrError) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type isBoolOrError_MaybeBool interface {
	isBoolOrError_MaybeBool()
}

type BoolOrError_Result struct {
	Result bool `protobuf:"varint,1,opt,name=result,oneof"`
}
type BoolOrError_Error struct {
	Error ErrorCode `protobuf:"varint,2,opt,name=error,enum=antha.quantstudio.v1.ErrorCode,oneof"`
}

func (*BoolOrError_Result) isBoolOrError_MaybeBool() {}
func (*BoolOrError_Error) isBoolOrError_MaybeBool()  {}

func (m *BoolOrError) GetMaybeBool() isBoolOrError_MaybeBool {
	if m != nil {
		return m.MaybeBool
	}
	return nil
}

func (m *BoolOrError) GetResult() bool {
	if x, ok := m.GetMaybeBool().(*BoolOrError_Result); ok {
		return x.Result
	}
	return false
}

func (m *BoolOrError) GetError() ErrorCode {
	if x, ok := m.GetMaybeBool().(*BoolOrError_Error); ok {
		return x.Error
	}
	return ErrorCode_UNINITIALIZED
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BoolOrError) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BoolOrError_OneofMarshaler, _BoolOrError_OneofUnmarshaler, _BoolOrError_OneofSizer, []interface{}{
		(*BoolOrError_Result)(nil),
		(*BoolOrError_Error)(nil),
	}
}

func _BoolOrError_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BoolOrError)
	// maybe_bool
	switch x := m.MaybeBool.(type) {
	case *BoolOrError_Result:
		t := uint64(0)
		if x.Result {
			t = 1
		}
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *BoolOrError_Error:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Error))
	case nil:
	default:
		return fmt.Errorf("BoolOrError.MaybeBool has unexpected type %T", x)
	}
	return nil
}

func _BoolOrError_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BoolOrError)
	switch tag {
	case 1: // maybe_bool.result
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.MaybeBool = &BoolOrError_Result{x != 0}
		return true, err
	case 2: // maybe_bool.error
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.MaybeBool = &BoolOrError_Error{ErrorCode(x)}
		return true, err
	default:
		return false, nil
	}
}

func _BoolOrError_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BoolOrError)
	// maybe_bool
	switch x := m.MaybeBool.(type) {
	case *BoolOrError_Result:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *BoolOrError_Error:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Error))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Session struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *Session) Reset()                    { *m = Session{} }
func (m *Session) String() string            { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()               {}
func (*Session) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Session) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Instrument struct {
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
}

func (m *Instrument) Reset()                    { *m = Instrument{} }
func (m *Instrument) String() string            { return proto.CompactTextString(m) }
func (*Instrument) ProtoMessage()               {}
func (*Instrument) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Instrument) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type SessionInstrument struct {
	Session    *Session    `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
	Instrument *Instrument `protobuf:"bytes,2,opt,name=instrument" json:"instrument,omitempty"`
}

func (m *SessionInstrument) Reset()                    { *m = SessionInstrument{} }
func (m *SessionInstrument) String() string            { return proto.CompactTextString(m) }
func (*SessionInstrument) ProtoMessage()               {}
func (*SessionInstrument) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *SessionInstrument) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *SessionInstrument) GetInstrument() *Instrument {
	if m != nil {
		return m.Instrument
	}
	return nil
}

type Credentials struct {
	User     string `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
}

func (m *Credentials) Reset()                    { *m = Credentials{} }
func (m *Credentials) String() string            { return proto.CompactTextString(m) }
func (*Credentials) ProtoMessage()               {}
func (*Credentials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Credentials) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *Credentials) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func init() {
	proto.RegisterType((*Blank)(nil), "antha.quantstudio.v1.Blank")
	proto.RegisterType((*SessionOrError)(nil), "antha.quantstudio.v1.SessionOrError")
	proto.RegisterType((*ExperimentFile)(nil), "antha.quantstudio.v1.ExperimentFile")
	proto.RegisterType((*Barcode)(nil), "antha.quantstudio.v1.Barcode")
	proto.RegisterType((*BlockTypeOrError)(nil), "antha.quantstudio.v1.BlockTypeOrError")
	proto.RegisterType((*Error)(nil), "antha.quantstudio.v1.Error")
	proto.RegisterType((*OptionalError)(nil), "antha.quantstudio.v1.OptionalError")
	proto.RegisterType((*StatusOrError)(nil), "antha.quantstudio.v1.StatusOrError")
	proto.RegisterType((*ExperimentRequest)(nil), "antha.quantstudio.v1.ExperimentRequest")
	proto.RegisterType((*TemplatedRequest)(nil), "antha.quantstudio.v1.TemplatedRequest")
	proto.RegisterType((*BoolOrError)(nil), "antha.quantstudio.v1.BoolOrError")
	proto.RegisterType((*Session)(nil), "antha.quantstudio.v1.Session")
	proto.RegisterType((*Instrument)(nil), "antha.quantstudio.v1.Instrument")
	proto.RegisterType((*SessionInstrument)(nil), "antha.quantstudio.v1.SessionInstrument")
	proto.RegisterType((*Credentials)(nil), "antha.quantstudio.v1.Credentials")
	proto.RegisterEnum("antha.quantstudio.v1.ErrorCode", ErrorCode_name, ErrorCode_value)
	proto.RegisterEnum("antha.quantstudio.v1.BlockType", BlockType_name, BlockType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for QuantStudioService service

type QuantStudioServiceClient interface {
	// Base QS API
	RunExperiment(ctx context.Context, in *ExperimentRequest, opts ...grpc.CallOption) (*OptionalError, error)
	RunExperimentFromTemplate(ctx context.Context, in *TemplatedRequest, opts ...grpc.CallOption) (*OptionalError, error)
	RunExperimentNonblocking(ctx context.Context, in *ExperimentRequest, opts ...grpc.CallOption) (*OptionalError, error)
	RunExperimentFromTemplateNonblocking(ctx context.Context, in *TemplatedRequest, opts ...grpc.CallOption) (*OptionalError, error)
	OpenTray(ctx context.Context, in *SessionInstrument, opts ...grpc.CallOption) (*OptionalError, error)
	CloseTray(ctx context.Context, in *SessionInstrument, opts ...grpc.CallOption) (*OptionalError, error)
	IsTrayIn(ctx context.Context, in *SessionInstrument, opts ...grpc.CallOption) (*BoolOrError, error)
	StartSession(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*SessionOrError, error)
	EndSession(ctx context.Context, in *Session, opts ...grpc.CallOption) (*OptionalError, error)
	GetBlockType(ctx context.Context, in *SessionInstrument, opts ...grpc.CallOption) (*BlockTypeOrError, error)
	GetInstrumentState(ctx context.Context, in *SessionInstrument, opts ...grpc.CallOption) (*StatusOrError, error)
	StopCurrentExperiment(ctx context.Context, in *SessionInstrument, opts ...grpc.CallOption) (*OptionalError, error)
}

type quantStudioServiceClient struct {
	cc *grpc.ClientConn
}

func NewQuantStudioServiceClient(cc *grpc.ClientConn) QuantStudioServiceClient {
	return &quantStudioServiceClient{cc}
}

func (c *quantStudioServiceClient) RunExperiment(ctx context.Context, in *ExperimentRequest, opts ...grpc.CallOption) (*OptionalError, error) {
	out := new(OptionalError)
	err := grpc.Invoke(ctx, "/antha.quantstudio.v1.QuantStudioService/RunExperiment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quantStudioServiceClient) RunExperimentFromTemplate(ctx context.Context, in *TemplatedRequest, opts ...grpc.CallOption) (*OptionalError, error) {
	out := new(OptionalError)
	err := grpc.Invoke(ctx, "/antha.quantstudio.v1.QuantStudioService/RunExperimentFromTemplate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quantStudioServiceClient) RunExperimentNonblocking(ctx context.Context, in *ExperimentRequest, opts ...grpc.CallOption) (*OptionalError, error) {
	out := new(OptionalError)
	err := grpc.Invoke(ctx, "/antha.quantstudio.v1.QuantStudioService/RunExperimentNonblocking", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quantStudioServiceClient) RunExperimentFromTemplateNonblocking(ctx context.Context, in *TemplatedRequest, opts ...grpc.CallOption) (*OptionalError, error) {
	out := new(OptionalError)
	err := grpc.Invoke(ctx, "/antha.quantstudio.v1.QuantStudioService/RunExperimentFromTemplateNonblocking", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quantStudioServiceClient) OpenTray(ctx context.Context, in *SessionInstrument, opts ...grpc.CallOption) (*OptionalError, error) {
	out := new(OptionalError)
	err := grpc.Invoke(ctx, "/antha.quantstudio.v1.QuantStudioService/OpenTray", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quantStudioServiceClient) CloseTray(ctx context.Context, in *SessionInstrument, opts ...grpc.CallOption) (*OptionalError, error) {
	out := new(OptionalError)
	err := grpc.Invoke(ctx, "/antha.quantstudio.v1.QuantStudioService/CloseTray", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quantStudioServiceClient) IsTrayIn(ctx context.Context, in *SessionInstrument, opts ...grpc.CallOption) (*BoolOrError, error) {
	out := new(BoolOrError)
	err := grpc.Invoke(ctx, "/antha.quantstudio.v1.QuantStudioService/IsTrayIn", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quantStudioServiceClient) StartSession(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*SessionOrError, error) {
	out := new(SessionOrError)
	err := grpc.Invoke(ctx, "/antha.quantstudio.v1.QuantStudioService/StartSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quantStudioServiceClient) EndSession(ctx context.Context, in *Session, opts ...grpc.CallOption) (*OptionalError, error) {
	out := new(OptionalError)
	err := grpc.Invoke(ctx, "/antha.quantstudio.v1.QuantStudioService/EndSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quantStudioServiceClient) GetBlockType(ctx context.Context, in *SessionInstrument, opts ...grpc.CallOption) (*BlockTypeOrError, error) {
	out := new(BlockTypeOrError)
	err := grpc.Invoke(ctx, "/antha.quantstudio.v1.QuantStudioService/GetBlockType", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quantStudioServiceClient) GetInstrumentState(ctx context.Context, in *SessionInstrument, opts ...grpc.CallOption) (*StatusOrError, error) {
	out := new(StatusOrError)
	err := grpc.Invoke(ctx, "/antha.quantstudio.v1.QuantStudioService/GetInstrumentState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quantStudioServiceClient) StopCurrentExperiment(ctx context.Context, in *SessionInstrument, opts ...grpc.CallOption) (*OptionalError, error) {
	out := new(OptionalError)
	err := grpc.Invoke(ctx, "/antha.quantstudio.v1.QuantStudioService/StopCurrentExperiment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for QuantStudioService service

type QuantStudioServiceServer interface {
	// Base QS API
	RunExperiment(context.Context, *ExperimentRequest) (*OptionalError, error)
	RunExperimentFromTemplate(context.Context, *TemplatedRequest) (*OptionalError, error)
	RunExperimentNonblocking(context.Context, *ExperimentRequest) (*OptionalError, error)
	RunExperimentFromTemplateNonblocking(context.Context, *TemplatedRequest) (*OptionalError, error)
	OpenTray(context.Context, *SessionInstrument) (*OptionalError, error)
	CloseTray(context.Context, *SessionInstrument) (*OptionalError, error)
	IsTrayIn(context.Context, *SessionInstrument) (*BoolOrError, error)
	StartSession(context.Context, *Credentials) (*SessionOrError, error)
	EndSession(context.Context, *Session) (*OptionalError, error)
	GetBlockType(context.Context, *SessionInstrument) (*BlockTypeOrError, error)
	GetInstrumentState(context.Context, *SessionInstrument) (*StatusOrError, error)
	StopCurrentExperiment(context.Context, *SessionInstrument) (*OptionalError, error)
}

func RegisterQuantStudioServiceServer(s *grpc.Server, srv QuantStudioServiceServer) {
	s.RegisterService(&_QuantStudioService_serviceDesc, srv)
}

func _QuantStudioService_RunExperiment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExperimentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuantStudioServiceServer).RunExperiment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antha.quantstudio.v1.QuantStudioService/RunExperiment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuantStudioServiceServer).RunExperiment(ctx, req.(*ExperimentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuantStudioService_RunExperimentFromTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TemplatedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuantStudioServiceServer).RunExperimentFromTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antha.quantstudio.v1.QuantStudioService/RunExperimentFromTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuantStudioServiceServer).RunExperimentFromTemplate(ctx, req.(*TemplatedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuantStudioService_RunExperimentNonblocking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExperimentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuantStudioServiceServer).RunExperimentNonblocking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antha.quantstudio.v1.QuantStudioService/RunExperimentNonblocking",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuantStudioServiceServer).RunExperimentNonblocking(ctx, req.(*ExperimentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuantStudioService_RunExperimentFromTemplateNonblocking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TemplatedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuantStudioServiceServer).RunExperimentFromTemplateNonblocking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antha.quantstudio.v1.QuantStudioService/RunExperimentFromTemplateNonblocking",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuantStudioServiceServer).RunExperimentFromTemplateNonblocking(ctx, req.(*TemplatedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuantStudioService_OpenTray_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionInstrument)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuantStudioServiceServer).OpenTray(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antha.quantstudio.v1.QuantStudioService/OpenTray",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuantStudioServiceServer).OpenTray(ctx, req.(*SessionInstrument))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuantStudioService_CloseTray_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionInstrument)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuantStudioServiceServer).CloseTray(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antha.quantstudio.v1.QuantStudioService/CloseTray",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuantStudioServiceServer).CloseTray(ctx, req.(*SessionInstrument))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuantStudioService_IsTrayIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionInstrument)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuantStudioServiceServer).IsTrayIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antha.quantstudio.v1.QuantStudioService/IsTrayIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuantStudioServiceServer).IsTrayIn(ctx, req.(*SessionInstrument))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuantStudioService_StartSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credentials)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuantStudioServiceServer).StartSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antha.quantstudio.v1.QuantStudioService/StartSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuantStudioServiceServer).StartSession(ctx, req.(*Credentials))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuantStudioService_EndSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Session)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuantStudioServiceServer).EndSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antha.quantstudio.v1.QuantStudioService/EndSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuantStudioServiceServer).EndSession(ctx, req.(*Session))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuantStudioService_GetBlockType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionInstrument)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuantStudioServiceServer).GetBlockType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antha.quantstudio.v1.QuantStudioService/GetBlockType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuantStudioServiceServer).GetBlockType(ctx, req.(*SessionInstrument))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuantStudioService_GetInstrumentState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionInstrument)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuantStudioServiceServer).GetInstrumentState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antha.quantstudio.v1.QuantStudioService/GetInstrumentState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuantStudioServiceServer).GetInstrumentState(ctx, req.(*SessionInstrument))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuantStudioService_StopCurrentExperiment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionInstrument)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuantStudioServiceServer).StopCurrentExperiment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antha.quantstudio.v1.QuantStudioService/StopCurrentExperiment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuantStudioServiceServer).StopCurrentExperiment(ctx, req.(*SessionInstrument))
	}
	return interceptor(ctx, in, info, handler)
}

var _QuantStudioService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "antha.quantstudio.v1.QuantStudioService",
	HandlerType: (*QuantStudioServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunExperiment",
			Handler:    _QuantStudioService_RunExperiment_Handler,
		},
		{
			MethodName: "RunExperimentFromTemplate",
			Handler:    _QuantStudioService_RunExperimentFromTemplate_Handler,
		},
		{
			MethodName: "RunExperimentNonblocking",
			Handler:    _QuantStudioService_RunExperimentNonblocking_Handler,
		},
		{
			MethodName: "RunExperimentFromTemplateNonblocking",
			Handler:    _QuantStudioService_RunExperimentFromTemplateNonblocking_Handler,
		},
		{
			MethodName: "OpenTray",
			Handler:    _QuantStudioService_OpenTray_Handler,
		},
		{
			MethodName: "CloseTray",
			Handler:    _QuantStudioService_CloseTray_Handler,
		},
		{
			MethodName: "IsTrayIn",
			Handler:    _QuantStudioService_IsTrayIn_Handler,
		},
		{
			MethodName: "StartSession",
			Handler:    _QuantStudioService_StartSession_Handler,
		},
		{
			MethodName: "EndSession",
			Handler:    _QuantStudioService_EndSession_Handler,
		},
		{
			MethodName: "GetBlockType",
			Handler:    _QuantStudioService_GetBlockType_Handler,
		},
		{
			MethodName: "GetInstrumentState",
			Handler:    _QuantStudioService_GetInstrumentState_Handler,
		},
		{
			MethodName: "StopCurrentExperiment",
			Handler:    _QuantStudioService_StopCurrentExperiment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/antha-lang/antha/driver/antha_quantstudio_v1/quantstudio.proto",
}

func init() {
	proto.RegisterFile("github.com/antha-lang/antha/driver/antha_quantstudio_v1/quantstudio.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1173 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xd9, 0x6e, 0xdb, 0x46,
	0x17, 0x96, 0x64, 0xcb, 0x92, 0x8e, 0x96, 0x50, 0x93, 0xe5, 0x57, 0x9c, 0xfc, 0x48, 0xca, 0x04,
	0x49, 0x11, 0xa0, 0x4e, 0xe2, 0x14, 0x4d, 0x03, 0xb4, 0x40, 0x28, 0x71, 0x1c, 0x13, 0x55, 0x48,
	0x75, 0x48, 0x79, 0x29, 0x50, 0x10, 0x94, 0x35, 0xb1, 0x89, 0xd0, 0x24, 0x43, 0x0e, 0xdd, 0xfa,
	0x1d, 0x8a, 0xf6, 0xa2, 0xd7, 0x05, 0xfa, 0x24, 0x7d, 0xa8, 0xf6, 0x05, 0x8a, 0xe1, 0x22, 0x51,
	0xae, 0x64, 0x2b, 0x4e, 0x72, 0xc7, 0x39, 0xfb, 0x77, 0xe6, 0x9b, 0x33, 0x43, 0x50, 0x0e, 0x6d,
	0x76, 0x14, 0x8d, 0x36, 0x0e, 0xbc, 0xe3, 0xc7, 0x96, 0xcb, 0x8e, 0xac, 0x2f, 0x1c, 0xcb, 0x3d,
	0x4c, 0x3e, 0x1f, 0x8f, 0x03, 0xfb, 0x84, 0x06, 0xc9, 0xc2, 0x7c, 0x17, 0x59, 0x2e, 0x0b, 0x59,
	0x34, 0xb6, 0x3d, 0xf3, 0xe4, 0xe9, 0xe3, 0xdc, 0x72, 0xc3, 0x0f, 0x3c, 0xe6, 0xa1, 0x6b, 0xb1,
	0xdd, 0x46, 0x5e, 0x71, 0xf2, 0x54, 0xac, 0x40, 0xb9, 0xeb, 0x58, 0xee, 0x5b, 0xf1, 0xaf, 0x22,
	0xb4, 0x74, 0x1a, 0x86, 0xb6, 0xe7, 0x6a, 0x01, 0x0e, 0x02, 0x2f, 0x40, 0x2f, 0xa0, 0x12, 0x26,
	0x92, 0x4e, 0xf1, 0x6e, 0xf1, 0xf3, 0xfa, 0xe6, 0xff, 0x37, 0xe6, 0xc5, 0xd8, 0x48, 0xdd, 0xb6,
	0x0b, 0x24, 0xb3, 0x47, 0xcf, 0xa0, 0x4c, 0x79, 0x8c, 0x4e, 0x29, 0x76, 0xbc, 0x35, 0xdf, 0x31,
	0x4e, 0xb3, 0x5d, 0x20, 0x89, 0x2d, 0x77, 0x1a, 0xf1, 0x5a, 0x3a, 0x2b, 0xe7, 0x39, 0xc5, 0xe5,
	0x72, 0xa7, 0xd8, 0xb6, 0x5b, 0x81, 0x72, 0x40, 0x7d, 0xe7, 0x54, 0x14, 0xa1, 0x85, 0x7f, 0xf6,
	0x69, 0x60, 0x1f, 0x53, 0x97, 0x6d, 0xd9, 0x0e, 0x45, 0x02, 0xac, 0x44, 0x81, 0x13, 0xd7, 0x5e,
	0x23, 0xfc, 0x53, 0xbc, 0x07, 0x95, 0xae, 0x15, 0x1c, 0x78, 0x63, 0x8a, 0x3a, 0x50, 0x19, 0x25,
	0x9f, 0xa9, 0x41, 0xb6, 0x14, 0xff, 0x28, 0x82, 0xd0, 0x75, 0xbc, 0x83, 0xb7, 0xc6, 0xa9, 0x4f,
	0xb3, 0x5e, 0xbc, 0x04, 0x18, 0x71, 0x99, 0xc9, 0x4e, 0xfd, 0xc4, 0xa3, 0xb5, 0x79, 0x67, 0x51,
	0x81, 0xa9, 0xef, 0x76, 0x81, 0xd4, 0x46, 0xd9, 0xe2, 0x52, 0x2d, 0xe9, 0x22, 0x10, 0x8e, 0xad,
	0xd3, 0x11, 0x35, 0xa7, 0xc9, 0xc5, 0x6f, 0xa0, 0x8c, 0xd3, 0x7e, 0xad, 0x4e, 0xea, 0x5f, 0x58,
	0x4d, 0x6c, 0xda, 0xf3, 0xc6, 0x94, 0xc4, 0xc6, 0xe2, 0x2f, 0x45, 0x68, 0x6a, 0x3e, 0xb3, 0x3d,
	0xd7, 0x72, 0xf0, 0x6c, 0xdb, 0x8b, 0xcb, 0xb7, 0x1d, 0x3d, 0xcf, 0xa3, 0xb9, 0x38, 0xf9, 0x14,
	0x51, 0x13, 0xea, 0x09, 0xa2, 0x78, 0x29, 0xfe, 0x5e, 0x84, 0xa6, 0xce, 0x2c, 0x16, 0x85, 0x53,
	0xd6, 0xad, 0x85, 0xb1, 0x60, 0x49, 0x5c, 0xdb, 0x05, 0x92, 0x3a, 0x5c, 0xbe, 0xa8, 0x16, 0x34,
	0x92, 0xa2, 0x92, 0x40, 0xe2, 0x3f, 0x45, 0x68, 0x4f, 0xc9, 0x44, 0xe8, 0xbb, 0x88, 0x86, 0x0c,
	0xed, 0x00, 0x4a, 0xf9, 0x6d, 0xda, 0x6e, 0xc8, 0x82, 0x88, 0x2b, 0xd3, 0xae, 0x3d, 0x3c, 0xf7,
	0x68, 0x28, 0x13, 0x73, 0xd2, 0x0e, 0xcf, 0x8a, 0xd0, 0x6b, 0xb8, 0x42, 0x27, 0xc9, 0xcc, 0x37,
	0xb6, 0x43, 0x53, 0x8e, 0xdc, 0x5f, 0x00, 0x60, 0x86, 0xe6, 0xa4, 0x45, 0x67, 0x69, 0xff, 0x7c,
	0xca, 0xec, 0x95, 0xf3, 0x8e, 0x6d, 0x7a, 0x12, 0xa6, 0xc4, 0xff, 0xad, 0x04, 0x82, 0x41, 0x8f,
	0x7d, 0xc7, 0x62, 0x74, 0xfc, 0xa9, 0x41, 0x2b, 0xd0, 0x64, 0x69, 0xae, 0xf7, 0x87, 0xdc, 0xc8,
	0x5c, 0x3f, 0x08, 0x30, 0xba, 0x03, 0x75, 0x2f, 0x62, 0x7e, 0xc4, 0x4c, 0xdf, 0x62, 0x47, 0x9d,
	0xd5, 0x78, 0x0e, 0x40, 0x22, 0x1a, 0x58, 0xec, 0x48, 0x74, 0xa1, 0xde, 0xf5, 0x3c, 0x27, 0xa3,
	0x66, 0x07, 0xd6, 0x02, 0x1a, 0x46, 0x4e, 0x82, 0xbf, 0xca, 0x99, 0x97, 0xac, 0x2f, 0xcf, 0xbc,
	0x06, 0x40, 0x7a, 0xc0, 0x3d, 0xcf, 0x11, 0x6f, 0x42, 0x25, 0x6d, 0x1e, 0x6a, 0x41, 0xc9, 0x1e,
	0xa7, 0xa3, 0xa9, 0x64, 0x8f, 0xc5, 0xdb, 0x00, 0xb9, 0xee, 0x25, 0xda, 0xd2, 0x44, 0xfb, 0x6b,
	0x11, 0xda, 0xff, 0x69, 0x3b, 0x6f, 0xcc, 0xfb, 0x0c, 0xf0, 0xe9, 0xf8, 0x7e, 0x09, 0x90, 0xdb,
	0xec, 0x64, 0x67, 0xee, 0xce, 0xf7, 0xcd, 0xed, 0x72, 0xce, 0x47, 0xfc, 0x16, 0xea, 0xbd, 0x80,
	0x8e, 0xa9, 0xcb, 0x6c, 0xcb, 0x09, 0x11, 0x82, 0xd5, 0x28, 0xa4, 0x41, 0x8a, 0x27, 0xfe, 0x46,
	0xeb, 0x50, 0xf5, 0xad, 0x30, 0xfc, 0xc9, 0x0b, 0x32, 0x24, 0x93, 0xf5, 0xa3, 0xbf, 0x57, 0xa0,
	0x36, 0xe9, 0x16, 0x6a, 0x43, 0x73, 0xa8, 0x2a, 0xaa, 0x62, 0x28, 0x52, 0x5f, 0xf9, 0x01, 0xcb,
	0x42, 0x01, 0x5d, 0x85, 0x2b, 0x3a, 0xd6, 0x75, 0x45, 0x53, 0x4d, 0x45, 0xdd, 0x91, 0xfa, 0x8a,
	0x2c, 0x14, 0xd1, 0x35, 0x10, 0x32, 0x21, 0xde, 0x53, 0x74, 0x43, 0x51, 0x5f, 0x09, 0x25, 0xb4,
	0x0e, 0x37, 0xa4, 0xa1, 0xb1, 0x8d, 0x55, 0x43, 0xe9, 0x49, 0x06, 0x57, 0x6e, 0x49, 0x4a, 0x7f,
	0x48, 0xb0, 0xb0, 0x82, 0x6e, 0xc2, 0xf5, 0xa1, 0x8e, 0x89, 0x29, 0xf5, 0x7a, 0xda, 0x50, 0x35,
	0x4c, 0x59, 0xd1, 0xa5, 0x6e, 0x1f, 0xcb, 0xc2, 0x2a, 0x0f, 0x36, 0x90, 0x74, 0x7d, 0x57, 0x23,
	0xb2, 0x89, 0xf7, 0x06, 0x0a, 0xc1, 0xb2, 0x50, 0x46, 0x37, 0x00, 0x29, 0xaa, 0x6e, 0x90, 0xe1,
	0x6b, 0xac, 0x1a, 0xe6, 0x50, 0xfd, 0x4e, 0xd5, 0x76, 0x55, 0x61, 0x0d, 0xdd, 0x86, 0x4e, 0x4e,
	0xae, 0x6a, 0x86, 0xd9, 0xd3, 0x54, 0x15, 0xf7, 0x0c, 0x2c, 0x0b, 0x15, 0x1e, 0x2b, 0xa7, 0x25,
	0x58, 0x92, 0xf7, 0x85, 0xea, 0x99, 0x58, 0x64, 0xa8, 0xaa, 0xbc, 0xe0, 0x1a, 0xba, 0x0e, 0xed,
	0x9c, 0x7c, 0x20, 0x0d, 0x75, 0x2c, 0x0b, 0x80, 0xfe, 0x07, 0x57, 0x73, 0x62, 0x45, 0x35, 0x31,
	0x21, 0x1a, 0x11, 0xea, 0x67, 0x72, 0x73, 0x70, 0xa6, 0xa1, 0x99, 0xba, 0x21, 0x11, 0x43, 0x68,
	0x70, 0xf8, 0x39, 0xad, 0x41, 0xa4, 0x7d, 0x53, 0x1b, 0x60, 0x15, 0xcb, 0x42, 0x73, 0x9e, 0xae,
	0xd7, 0xd7, 0x78, 0xba, 0x16, 0xea, 0xc0, 0x35, 0xbc, 0x37, 0xc0, 0x44, 0x99, 0x20, 0xda, 0xd2,
	0x86, 0xaa, 0x2c, 0x5c, 0xe1, 0x4d, 0xcb, 0x69, 0x38, 0x9a, 0xb4, 0x14, 0x81, 0x07, 0xcc, 0xa9,
	0x76, 0x89, 0x62, 0xe0, 0x54, 0xd7, 0x46, 0x77, 0xe0, 0x56, 0x4e, 0x17, 0xef, 0x59, 0xb2, 0x1d,
	0x89, 0x01, 0x7a, 0xf4, 0x06, 0x6a, 0x93, 0xbb, 0x13, 0xd5, 0xa0, 0x9c, 0xc8, 0x0b, 0xbc, 0x1f,
	0x12, 0x89, 0x6b, 0x93, 0x88, 0x6c, 0xea, 0xd2, 0xeb, 0x41, 0x1f, 0x0b, 0x15, 0xce, 0x8a, 0x5d,
	0xdc, 0xef, 0x9b, 0xcf, 0xbe, 0xfe, 0xd2, 0xdc, 0x7c, 0x12, 0xf5, 0x85, 0xea, 0x44, 0xf4, 0xe2,
	0x2b, 0xf3, 0xe9, 0x13, 0x2e, 0xaa, 0xe5, 0x45, 0x9b, 0xb1, 0x08, 0x36, 0xff, 0xac, 0x01, 0xfa,
	0x9e, 0xb3, 0x58, 0x8f, 0x59, 0xac, 0xd3, 0xe0, 0xc4, 0x3e, 0xa0, 0xe8, 0x47, 0x68, 0x92, 0xc8,
	0x9d, 0x4e, 0x1a, 0xf4, 0xf0, 0xa2, 0x59, 0x94, 0xce, 0xc8, 0xf5, 0x7b, 0xf3, 0x0d, 0x67, 0xaf,
	0xd9, 0x23, 0xb8, 0x39, 0x13, 0x7e, 0x2b, 0xf0, 0x8e, 0xb3, 0x69, 0x8b, 0x1e, 0xcc, 0x8f, 0x70,
	0x76, 0x1a, 0x2f, 0x9b, 0xa9, 0x33, 0x93, 0x49, 0xf5, 0xdc, 0xf8, 0xf9, 0x60, 0xbb, 0x87, 0x1f,
	0x19, 0x53, 0x08, 0xf7, 0x17, 0x62, 0xca, 0x67, 0xfd, 0xa8, 0xf0, 0xf6, 0xa0, 0xaa, 0xf9, 0xd4,
	0x35, 0x02, 0xeb, 0x14, 0x2d, 0x7b, 0x03, 0x2d, 0x17, 0x79, 0x1f, 0x6a, 0x3d, 0xc7, 0x0b, 0xe9,
	0x27, 0x08, 0xbd, 0x03, 0x55, 0x25, 0xe4, 0x71, 0x15, 0x77, 0xf9, 0xc8, 0x9f, 0x2d, 0xb8, 0xc7,
	0x72, 0x57, 0xd2, 0x2e, 0x34, 0x74, 0x66, 0x05, 0x2c, 0xbb, 0x36, 0x16, 0xb8, 0xe4, 0x66, 0xf1,
	0xfa, 0xfd, 0x73, 0xd3, 0x67, 0x81, 0x07, 0x00, 0xd8, 0x1d, 0x67, 0x61, 0xcf, 0xbf, 0x38, 0x96,
	0x6b, 0x81, 0x09, 0x8d, 0x57, 0x94, 0x4d, 0x4f, 0xf8, 0xd2, 0x6d, 0x78, 0x70, 0xc1, 0x3b, 0x3b,
	0x2b, 0x79, 0x04, 0xe8, 0x15, 0x65, 0x53, 0x47, 0xfe, 0xae, 0xa4, 0x1f, 0xbc, 0x8f, 0xb3, 0xaf,
	0x53, 0x0a, 0xd7, 0x75, 0xe6, 0xf9, 0xbd, 0x28, 0x08, 0xa8, 0xcb, 0x2e, 0x1e, 0x16, 0x97, 0xa3,
	0xcb, 0x68, 0x2d, 0xfe, 0x67, 0x7b, 0xf6, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd4, 0x98, 0x79,
	0xe1, 0x00, 0x0e, 0x00, 0x00,
}
